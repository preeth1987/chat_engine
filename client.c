/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
/*
 * main.c - Auto-generated by Anjuta's Makefile project wizard
 * 
 */
#include "header.h"
#define PAIR_NO1 1
#define PAIR_NO2 2
#define PAIR_NO3 3
#define PAIR_NO4 4
#define START_POS 0
#define ME 0
#define BUDDY 1
#define NONE 2
int sd;
	
WINDOW *win1,*win2,*win3,*win4,*win1_1,*win2_1,*win3_1,*win4_1;
int startx, starty, width, height,pos=START_POS,maxy_diag=0;
char str[MAXLINE+1],tmp_str[MAXLINE+1];
int exitthread=0;

pthread_t thread1, thread2;

char me[NAMELEN+1],buddy[NAMELEN+1];
int len;
char buff[MAXLINE+1],c;
size_t n;
size_t my_name_len,buddy_name_len;
int connect_1=0,connect_2=0;

fd_set fds,rfds,wfds;
int rc;

void init(void);
void clear_scr(void);
void read_win(void);
void write_win(const char*,int);
void handle_command(const char*);

void sigint_handler(int);

void sound(const char*);


void *fun1(void *ptr);
void *fun2(void *ptr);

void exit_chat(void);

int main(int argc, char* argv[])
{
	
	struct sockaddr_in cli;
	
	struct hostent *hp;


	int  iret1, iret2;
	char *msg = "Using Threads";
	

	if(argc<2)
	{
		printf("USAGE: %s [-h hostname | -i ip]",argv[0]);
		exit(1);
	}
	
	sd=socket(AF_INET,SOCK_STREAM,0);
	
	if(sd<0)
	{
		perror("ERROR in creation of socket");
		exit(1);
	}
	
	bzero((struct sockaddr_in*)&cli, sizeof(cli));
	
	cli.sin_family=AF_INET;
	cli.sin_port=htons(PORTNO);

	while((c=getopt(argc,argv,"h:i")) != -1)
	{
		switch(c)
		{
			case 'h':
				hp=gethostbyname(argv[2]);
				if(hp==NULL)
				{	
					perror("ERROR no such host");
					exit(1);
				}
				bcopy((char*)hp->h_addr,(char*)&cli.sin_addr,hp->h_length);
				break;
			case 'i':
				cli.sin_addr.s_addr=inet_addr(argv[2]);
				break;
		}
	}
	
	if(connect(sd,(struct sockaddr*)&cli, sizeof(cli)) < 0)
	{
		perror("ERROR in connecting to socket");
		exit(1);
	}
	
	/*register SIGINT signal*/
	signal(SIGINT,sigint_handler);
	
	
		
	/*read name of user and initialize screen*/
	system("clear");
	printf("%s\n\n",WELCOME_MESSAGE);
	printf("ENTER YOUR NICK NAME: ");
	scanf("%[^\n]",me);
	
	init();
	wmove(win3_1,1,1);
	wrefresh(win3_1);
	
	/*create 2 threads to handle input and output*/


	iret1 = pthread_create( &thread1, NULL, fun1, (void*)msg);
	sleep(2);
     	iret2 = pthread_create( &thread2, NULL, fun2, (void*)msg);
	
	pthread_join( thread1, NULL);
     	pthread_join( thread2, NULL);
	
	
	/*EXIT: clear screen and close connections*/
	exit_chat();
		
	return 0;
}

/*signal handler for signal SIGINT(ctrl-c)*/
void sigint_handler(int sig_num)
{
	write_win("press enter to exit..\n",NONE);
	/*EXIT: clear screen and close connections*/
	exit_chat();
}
	
/*create windows and set up screen*/
void init(void)
{
	initscr();			/* Start curses mode */
	start_color();	
	cbreak();			
	keypad(stdscr, TRUE);		

	init_pair(PAIR_NO1,COLOR_GREEN,COLOR_BLACK);
	init_pair(PAIR_NO2,COLOR_RED,COLOR_BLACK);
	init_pair(PAIR_NO3,COLOR_BLUE,COLOR_BLACK);
	init_pair(PAIR_NO4,COLOR_MAGENTA,COLOR_BLACK);
	
	refresh();
	
	

	height = (int)((LINES*3)/4)-1;
	width = (int)((COLS*3)/4)-1;
	starty = 0;	
	startx = 0;
	refresh();
	win1 = newwin(height, width, starty, startx);
	
	
	win1_1=subwin(win1,height-2,width-2,starty+1,startx+1);
	
	wsetscrreg(win1_1,1,height-2);
	maxy_diag=height-3;
	scrollok(win1_1,TRUE);
	idlok(win1_1,TRUE);

	wattron(win1,COLOR_PAIR(PAIR_NO1) | A_BOLD);
	box(win1,0,0);
	wattroff(win1,COLOR_PAIR(PAIR_NO1) | A_BOLD);
	

		
	height = (int)((LINES*3)/4)-1;
	width = (int)(COLS/4)-1;
	starty = 0;	
	startx = (int)((COLS*3)/4);
	refresh();
	win2 = newwin(height, width, starty, startx);

	win2_1=subwin(win2,height-2,width-2,starty+1,startx+1);

	wattron(win2,COLOR_PAIR(PAIR_NO1) | A_BOLD);
	box(win2,0,0);
	wattroff(win2,COLOR_PAIR(PAIR_NO1) | A_BOLD);
		
	
	height = (int)(LINES/4)-1;
	width = (int)(COLS*3/4)-1;
	starty = (int)((LINES*3)/4);	
	startx = 0;
	refresh();
	win3 = newwin(height, width, starty, startx);
	
	
	wattron(win3,COLOR_PAIR(PAIR_NO1) | A_BOLD);
	box(win3,0,0);
	wattroff(win3,COLOR_PAIR(PAIR_NO1) | A_BOLD);

	
	win3_1=subwin(win3,height-2,width-2,starty+1,startx+1);

	
	height = (int)(LINES/4)-1;
	width = (int)(COLS/4)-1;
	starty = (int)((LINES*3)/4);	
	startx = (int)(COLS*3/4);
	refresh();
	win4 = newwin(height, width, starty, startx);
	

	wattron(win4,COLOR_PAIR(PAIR_NO1) | A_BOLD);
	box(win4,0,0);
	wattroff(win4,COLOR_PAIR(PAIR_NO1) | A_BOLD);
	//win4_1=subwin(win4,8,28,29,75);
	
	win4_1=subwin(win4,height-2,width-2,starty+1,startx+1);

	
	wrefresh(win1);
	wrefresh(win2);
	wrefresh(win3);
	wrefresh(win4);
	
	wattron(win1_1,COLOR_PAIR(PAIR_NO1));
	wattron(win2_1,COLOR_PAIR(PAIR_NO2) | A_BOLD);
	wattron(win3_1,COLOR_PAIR(PAIR_NO1));	
	wattron(win4_1,COLOR_PAIR(PAIR_NO3)|A_BOLD);
		
	mvwprintw(win4_1,0,0,"SAMCHAT ENGINE 0.2");
	mvwprintw(win4_1,1,0,"BY: PREETHAM SINGH");
	
	wrefresh(win4_1);
	wattroff(win4_1,COLOR_PAIR(PAIR_NO3)|A_BOLD);

	echo();
}
	
/*write to window win1_1*/
void write_win(const char* st,int choice)
{
	int i=0;
	wrefresh(win1_1);
	
	wmove(win1_1,pos,0);
	switch(choice)
	{
		case NONE:
			
			wprintw(win1_1,"\t");
			for(i=0;i<strlen(st);i++)
			waddch(win1_1,st[i] | A_BOLD | COLOR_PAIR(PAIR_NO4));
			break;

		case ME:
			
			for(i=0;i<strlen(me);i++)
			waddch(win1_1,me[i] | A_BOLD);
			waddch(win1_1,':' | A_BOLD );
			wprintw(win1_1," %s",st);
			break;

		case BUDDY:
			
			for(i=0;i<strlen(buddy);i++)
			waddch(win1_1,buddy[i] | A_BOLD );
			waddch(win1_1,':' |A_BOLD );
			wprintw(win1_1," %s",st);
			break;
	}
	

	
	if(pos>=(maxy_diag-1))
		scroll(win1_1),pos=maxy_diag;
	else pos++;

	wrefresh(win1_1);
	wclear(win3_1);
	wmove(win3_1,1,1);
	wrefresh(win3_1);
	
}	

/*read from win3_1*/
void read_win(void)
{
	
	//int ch;
	//int i=0;
	
	//clear str
	bzero((char*)str,sizeof(str));
	
	//read from stdin
	wmove(win3_1,1,1);
	
	wscanw(win3_1,"%[^\n]s",str);
	
	wrefresh(win3_1);

	write_win(str,ME);

	return;
}

/*thread 1: handles reading from win3_1(stdin) and writing to socket*/
void *fun1(void *ptr)
{
	char msg[50]="welcome ",*tmp;
	
	my_name_len=strlen(me);

	if(me[my_name_len-1]=='\n')
		my_name_len--;

	char tmp1[NAMELEN+1];
	
	strcpy(tmp1,me);
	strcat(tmp1,"†");
	
	my_name_len=strlen(tmp1);

	/*send nick name to remote client*/
	write(sd,tmp1,my_name_len);
	
	//sleep(2);
	
	/*initialize windows using ncurses*/
	
	
	
	/*print about window*/
	
	
	

	//sleep(1);
	//connect_1=1;
	//write_win("connecting....",NONE);
	//sleep(2);
		
//#if 0
	{
		
		tmp=(char*)strcat(msg,me);
		sound(tmp);
	}
//#endif
	for(;;)
		{
			if(exitthread)
			{
				write_win("remote buddy closed connection...\npress enter to exit\n",NONE);
				sound("buddy is offline");
				break;
			}
				
			read_win();
			if(str[0]=='/')
			{
				handle_command(str);
				continue;
			}
	
			strcpy(buff,str);
			
			
			//if(buff[len-1] == '\n')
			//	len--;
			
			if(!connect_2)
				strcat(buff,"¢");
			len=strlen(buff);
			write(sd,buff,len);
			if(!strcmp(buff,"~/0./@10/^"))
			{
				write_win("remote buddy closed connection...\npress enter to exit\n",NONE);
				exitthread=1;
				sound("buddy is offline");
				break;
			}
			if(!strcmp(buff,"~/0./@10/~"))
			{		
				exitthread=1;
				write_win("server closed connection...\npress enter to exit\n",NONE);
				sound("server crashed");
				break;
			}
		}
   
}
/*thread 2: handles reading from socket and writing to win1_1(stdout)*/
void *fun2(void *ptr)
{

	char *str1,*str2,buddy_ip[20],*str3,tmp[NAMELEN+1];
				
	char m1[20]=" is online";
	char *t1,t2[NAMELEN+1];	

	FD_ZERO(&rfds);
	FD_SET(sd,&rfds);
	rc=select(sizeof(rfds), &rfds, (fd_set *)0, (fd_set *)0, (struct timeval *)0);
	
	if(rc==-1){
		perror("select failed");
		exit(1);
	}
	if(FD_ISSET(sd,&rfds))
	{			
				
	

				//read buddy name from remote client
				buddy_name_len=read(sd,buddy,NAMELEN);
				buddy[buddy_name_len]='\0';
	
				
				strcpy(tmp,buddy);
				str1=strtok(tmp,"@~");
				str2=strtok(NULL,"@~");
						
								
				strcpy(buddy,str1);
				strcpy(buddy_ip,str2);

				
				if((str3=strtok(NULL,"~¢"))!=NULL)
				{
					//write_win("THESE MESSAGES WERE SENT WHEN YOU WERE OFFLINE..\n",NONE);
					//str3=strtok(NULL,"~¢");
					//if(str3!=NULL)
						write_win("THESE MESSAGES WERE SENT WHEN YOU WERE OFFLINE..\n",NONE);
					while (str3 != NULL)
	 				{
		   				 write_win(str3,BUDDY);
		   				 str3 = strtok (NULL, "¢");
	 				}
				}
				
				//print buddy info	
				mvwprintw(win2_1,1,1,"%s",buddy);
				mvwprintw(win2_1,2,1,"%s",buddy_ip);
				wrefresh(win2_1);
				wmove(win3_1,1,1);
				wrefresh(win3_1);
				connect_2=1;
				//if(0)
				{
				
			strcpy(t2,buddy);
				t1=strcat(t2,m1);
			sound(t1);
		}
			FD_ZERO(&rfds);
			FD_SET(sd,&rfds);

     		for(;;)
		{
			
			
			if(exitthread)
			{
				write_win("remote buddy closed connection...\npress enter to exit\n",NONE);
				sound("buddy is offline");
				break;
			}

			rc=select(sizeof(rfds),&rfds,(fd_set *)0, (fd_set *)0,(struct timeval*)0);

			if (rc==-1) {
	  			perror("select failed");
	   			exit(1);
			}
		
			if(FD_ISSET(sd,&rfds))
			{	
		
				n=read(sd,buff,MAXLINE);
				buff[n]='\0';
				if(!strcmp(buff,"~/0./@10/^"))
				{		
					exitthread=1;
					write_win("remote buddy closed connection...\npress enter to exit\n",NONE);
					sound("buddy is offline");
					break;
				}
				if(!strcmp(buff,"~/0./@10/~"))
				{		
					exitthread=1;
					write_win("server closed connection...\npress enter to exit\n",NONE);
					sound("server crashed");
					break;
				}
	
				write_win(buff,BUDDY);
	
			}
			
		}

	}
}
/*handle command execution*/
void handle_command(const char* cmd)
{
	
	//write_win("executing command....");
	if(!strcmp(cmd,"/clear"))
	{
		pos=START_POS;
		wclear(win1_1);
		wrefresh(win1_1);
		wmove(win3_1,1,1);
		wrefresh(win3_1);	
	}
	else write_win("UNKNOWN COMMAND",NONE);
}

/*clear screen, memory and exit*/
void exit_chat(void)
{
	write(sd,"~/0./@10/^",10);

	refresh();
	wattron(win1_1,COLOR_PAIR(PAIR_NO1));
	wattron(win2_1,COLOR_PAIR(PAIR_NO2) | A_BOLD);
	wattron(win3_1,COLOR_PAIR(PAIR_NO1));

	
	refresh();
	endwin();

	system("clear");

	printf("THANK YOU FOR USING SAMCHAT ENGINE!\n");
	fflush(stdout);
	close(sd);
	exit(0);
}

void sound(const char* msg)
{

/*	if(fork()==0)
	{
		execl("/usr/bin/espeak","espeak",(char*)msg,(char*)0);
	}
*/
}
