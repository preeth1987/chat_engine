/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
/*
 * main.c - Auto-generated by Anjuta's Makefile project wizard
 * 
 */

#include "header.h"

void *fun1(void *ptr);
void *fun2(void *ptr);
void bye(void);
int sd1,newsd1,newsd2,portno1,clilen1,clilen2,first=0,connected=0;
size_t n;
char buff[MAXLINE+1];
char buddy1[NAMELEN+1],buddy2[NAMELEN+1];
size_t buddy_size1,buddy_size2;
struct sockaddr_in serv1,serv2,cli1,cli2;

fd_set fds,rfds,wfds;
int rc,z;

void sigint_handler(int);


int main(int argc, char* argv[])
{
	
	int pid;
	
	
	pthread_t thread1, thread2;
	int  iret1, iret2, newsd;
	char *msg = "Using Threads";
	

	/*if(argc<2)
	{
		printf("USAGE: %s <port no.>",argv[0]);
		exit(1);
	}*/

	signal(SIGINT,sigint_handler);
	atexit(bye);
	
	


	/*create socket 1*/
	sd1=socket(AF_INET,SOCK_STREAM,0);
	if(sd1<0)
	{
		perror("ERROR creating socket1");	
		exit(1);
	}

	bzero((struct sockaddr_in*)&serv1,sizeof(serv1));

	serv1.sin_family = AF_INET;
	serv1.sin_port = htons(PORTNO);	
	serv1.sin_addr.s_addr = INADDR_ANY;
	if(bind(sd1,(struct sockaddr*)&serv1,sizeof(serv1)) < 0)
	{
		perror("ERROR binding socket1");
		exit(1);
	}
	listen(sd1,5);
	

	/*CREATE CONCURRENT SERVER THAT SERVES ANY NUMBER OF PAIRS OF CLIENTS TO CHAT*/
	for(;;)
	{
			
		
		bzero((struct sockaddr_in*)&cli1,sizeof(cli1));
		bzero((struct sockaddr_in*)&cli2,sizeof(cli2));
		z=0;	
		FD_ZERO(&fds);
		
		FD_SET(sd1,&fds);
		
		while(z<2)
		{	
			
	
			rc = select(sizeof(fds), &fds, (fd_set *)0, (fd_set *)0, (struct timeval *)0);
	
			if (rc==-1) 
			{
		   		perror("select failed");
		  		exit(1);
			}
		
			if(FD_ISSET(sd1,&fds) && z<2)
			{
	
				if(z==0)
				{
					clilen1=sizeof(cli1);
					newsd=accept(sd1,(struct sockaddr*)&cli1,&clilen1);
					if(newsd<0)
					{
						perror("ERROR in accepting connection1");
						exit(1);
					}
					z++;
					newsd1=newsd;
					FD_ZERO(&fds);
					FD_SET(sd1,&fds);
				}
				else if(z==1)
				{
					clilen2=sizeof(cli2);
					newsd=accept(sd1,(struct sockaddr*)&cli2,&clilen2);
					if(newsd<0)
					{
						perror("ERROR in accepting connection1");
						exit(1);
					}
					z++;
					newsd2=newsd;
				}
			}

			
		}
		/*CREATE A PROCESS TO HANDLE EACH PAIR OF CHAT CLIENT...*/
		
		
		if((pid=fork()) < 0)
		{
			perror("ERROR creating child process: ");
			exit(1);
		}
		else if(pid==0)
		{
			close(sd1);
			
	
			/*CREATE 2  THREADS EACH TO HANDLE EACH CLIENT...*/
			iret1 = pthread_create( &thread1, NULL, fun1, (void*)msg);
			iret2 = pthread_create( &thread2, NULL, fun2, (void*)msg);
				
			pthread_join( thread1, NULL);
			pthread_join( thread2, NULL);
	
			write(newsd1,"~/0./@10/^",10);
			write(newsd2,"~/0./@10/^",10);	
			close(newsd1);
			close(newsd2);
		}
		
		close(newsd1);
		close(newsd2);
	}
	return 0;
	
}


void *fun1(void *ptr)
{

	char *tmp,*tmp1;
	char offline_msg[MAXLINE+1];

		
	
	FD_ZERO(&rfds);
	FD_SET(newsd1,&rfds);
	rc=select(sizeof(rfds), &rfds, (fd_set *)0, (fd_set *)0, (struct timeval *)0);
	
	if(rc==-1){
		perror("select failed");
		exit(1);
	}
	if(FD_ISSET(newsd1,&rfds))
	{
		buddy_size1=read(newsd1,buddy1,NAMELEN);
	
		
		
		tmp=strtok(buddy1,"†");
		tmp1=strtok(NULL,"†");
		
		if(tmp1!=NULL)
		strcpy(offline_msg,tmp1);
		
		strcpy(buddy1,tmp);

		buddy_size1=strlen(buddy1);
		
		snprintf(buddy1+buddy_size1,sizeof(buddy1)-buddy_size1,"@%s~",inet_ntoa(cli1.sin_addr));
		buddy_size1=strlen(buddy1);
		
		
		
	
		if(!first)
		{
			printf("%s <---> ",buddy1);fflush(stdout);
			first=1;
		}
		else
			printf("%s\n",buddy1);
	
		FD_ZERO(&wfds);
		
		FD_SET(newsd2,&wfds);
	
		rc = select(sizeof(wfds),(fd_set *)0,&wfds, (fd_set *)0, (struct timeval *)0);

		if (rc==-1) {
	  		perror("select failed");
	   		exit(1);
		}
	
		if(FD_ISSET(newsd2,&wfds))
		{
			write(newsd2,buddy1,(buddy_size1));
			
			if(tmp1!=NULL)
			{
			
				FD_ZERO(&wfds);
		
				FD_SET(newsd2,&wfds);
	
				rc = select(sizeof(wfds),(fd_set *)0,&wfds, (fd_set *)0, (struct timeval *)0);

				if (rc==-1) {
	  				perror("select failed");
	   				exit(1);
				}
				if(FD_ISSET(newsd2,&wfds))
				{
					//send offline messages also
			
					write(newsd2,offline_msg,strlen(offline_msg));
				
				}
			}

			FD_ZERO(&rfds);
			FD_SET(newsd1,&rfds);

			while(1)	
			{
				
				rc=select(sizeof(rfds),&rfds,(fd_set *)0, (fd_set *)0,(struct timeval*)0);

				if (rc==-1) {
	  				perror("select failed");
	   				exit(1);
				}
		
				if(FD_ISSET(newsd1,&rfds)){
					n=read(newsd1,buff,MAXLINE);
					if(n==0)
						exit(0);
					if(n>0)	
					{
						if(!strcmp(buff,"~/0./@10/^")) 
						{
							write(newsd2,buff,n);
							break;
						}		
						write(newsd2,buff,n);
					}
				}
				
			}/*while*/
		
		}
	}
   
}

void *fun2(void *ptr)
{

		char *tmp,*tmp1;
		char offline_msg[MAXLINE+1];


	
	FD_ZERO(&rfds);
	FD_SET(newsd2,&rfds);
	rc=select(sizeof(rfds), &rfds, (fd_set *)0, (fd_set *)0, (struct timeval *)0);
	
	if(rc==-1)
	{
		perror("select failed");
		exit(1);
	}
	if(FD_ISSET(newsd2,&rfds))
	{
		buddy_size2=read(newsd2,buddy2,NAMELEN);
	
		//char tmp1[NAMELEN+1],offline_msg[MAXLINE+1];
			
		
		tmp=strtok(buddy2,"†");
		tmp1=strtok(NULL,"†");
		if(tmp1!=NULL)
		strcpy(offline_msg,tmp1);
		
		strcpy(buddy2,tmp);
	
		buddy_size2=strlen(buddy2);
		snprintf(buddy2+buddy_size2,sizeof(buddy2)-buddy_size2,"@%s~",inet_ntoa(cli2.sin_addr));
		buddy_size2=strlen(buddy2);
		
		if(!first)
		{
			printf("%s <---> ",buddy2);fflush(stdout);
			first=1;
		}
		else
			printf("%s\n",buddy2);
	
		FD_ZERO(&wfds);
		
		FD_SET(newsd1,&wfds);
	
		rc = select(sizeof(wfds),(fd_set *)0,&wfds, (fd_set *)0, (struct timeval *)0);

		if (rc==-1) {
	  		perror("select failed");
	   		exit(1);
		}
	
		if(FD_ISSET(newsd1,&wfds))
		{
			write(newsd1,buddy2,(buddy_size2));

			//send offline messages also
			//if(tmp1!=NULL)
			//write(newsd2,offline_msg,strlen(offline_msg));

			if(tmp1!=NULL)
			{
			
				FD_ZERO(&wfds);
		
				FD_SET(newsd1,&wfds);
	
				rc = select(sizeof(wfds),(fd_set *)0,&wfds, (fd_set *)0, (struct timeval *)0);

				if (rc==-1) {
	  				perror("select failed");
	   				exit(1);
				}
				if(FD_ISSET(newsd1,&wfds))
				{
					//send offline messages also
			
					write(newsd1,offline_msg,strlen(offline_msg));
				
				}
			}

			FD_ZERO(&rfds);
			FD_SET(newsd2,&rfds);
		
			while(1)	
			{
				
				rc=select(sizeof(rfds),&rfds,(fd_set *)0, (fd_set *)0, (struct timeval*)0);

				if (rc==-1) {
	  				perror("select failed");
	   				exit(1);
				}
		
				if(FD_ISSET(newsd2,&rfds))
				{
					n=read(newsd2,buff,MAXLINE);
					if(n==0)
						exit(0);
					if(n>0)	
					{
						if(!strcmp(buff,"~/0./@10/^")) 
						{
							write(newsd1,buff,n);
							break;
						}	
						write(newsd1,buff,n);
					}
				}
			}/*while*/	
		}
	
	}
		
}

void bye(void)
{
	write(newsd2,"~/0./@10/~",10);
	write(newsd1,"~/0./@10/~",10);
	sleep(2);
	close(sd1);
	
	fflush(stdout);
	
}

void sigint_handler(int sig_num)
{
	write(newsd2,"~/0./@10/~",10);
	write(newsd1,"~/0./@10/~",10);
	sleep(2);	
	close(newsd1);
	close(newsd2);

	exit(0);
}
